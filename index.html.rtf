<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="pageTitle">Lector TTS Web</title>
    <!-- Incluyendo Tailwind CSS para un dise√±o moderno y responsive -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos base y de tipograf√≠a */
        body {
            background-color: #f7f7f7; 
            font-family: 'Inter', sans-serif;
            color: #333;
        }
        /* Estilos para la tarjeta principal (App Container) */
        #app {
            background-color: #ffffff;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.05), 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            border: 1px solid #e0e0e0;
        }
        /* Estilos para los botones */
        button {
            transition: all 0.2s ease-in-out;
            border-radius: 9999px; 
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        button:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }
        /* Estilo para el √°rea de texto */
        #textToRead {
            overflow-y: auto; 
            white-space: pre-wrap; 
            min-height: 250px; 
            border-color: #ccc;
            border-radius: 0.5rem; 
            color: #1f2937;
            /* Resalta el texto seleccionado en verde/azul para indicar el p√°rrafo actual */
            caret-color: #3b82f6; 
        }
        /* Estilos de slider m√°s limpios */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px; /* Un poco m√°s grande para mejor toque */
            height: 16px;
            border-radius: 50%;
            background: #3b82f6; /* Azul de Tailwind */
            cursor: pointer;
        }
        /* Estilo unificado para grupos de control y el indicador de p√°rrafo */
        .control-group {
            display: flex;
            align-items: center;
            padding: 0.5rem 1rem;
            border: 1px solid #ddd;
            border-radius: 0.75rem;
            background-color: #f9fafb;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); /* A√±adir sombra sutil */
        }
        
    </style>
</head>
<body class="p-4 sm:p-8 flex justify-center min-h-screen">

    <div id="app" class="w-full max-w-4xl p-6 sm:p-10 rounded-xl space-y-8">
        
        <h1 class="text-3xl sm:text-4xl font-extrabold text-gray-800 text-center" data-i18n="mainTitle">üéôÔ∏è Lector de Texto a Voz (TTS) Web</h1>
        <p class="text-center text-sm sm:text-base text-gray-500" data-i18n="subTitle">
            Carga un PDF, pega texto, ajusta el volumen y navega. Haz clic o selecciona texto para empezar a leer.
        </p>

        <!-- Controles de Audio y Navegaci√≥n -->
        <div class="flex flex-col space-y-6 p-5 bg-gray-50 rounded-xl border border-gray-200">
            
            <!-- Contenedor √öNICO de P√°rrafo, Idioma, Volumen, Velocidad (Side-by-side & Centrado) -->
            <div class="flex flex-wrap justify-center items-center text-sm font-medium text-gray-600 gap-3 sm:gap-4">
                
                <!-- P√°rrafo Actual (Dise√±o ajustado para ser horizontal como los otros) -->
                <div id="paragraph-display-box" class="control-group">
                    <span data-i18n="labelParagraphCurrent" class="text-gray-700 text-sm font-bold mr-2 whitespace-nowrap">P√°rrafo Actual:</span> 
                    <!-- Se redujo el tama√±o del n√∫mero para que quepa mejor en l√≠nea -->
                    <span id="paragraphIndexDisplay" class="font-extrabold text-lg text-blue-600">0 de 0</span>
                </div>
                
                <!-- Selector de Idioma -->
                <div class="control-group">
                    <label for="languageSelect" class="text-sm mr-2 whitespace-nowrap" data-i18n="labelLanguage">Idioma:</label>
                    <select id="languageSelect" class="p-1 border-none rounded-md bg-transparent focus:ring-0">
                        <option value="es">Espa√±ol üá™üá∏</option>
                        <option value="en">Ingl√©s üá¨üáß</option>
                    </select>
                </div>

                <!-- Volumen -->
                <div class="control-group">
                    <label for="volumeSlider" class="text-sm mr-2 whitespace-nowrap" data-i18n="labelVolume">Volumen:</label>
                    <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="1" class="w-20 h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                    <span id="volumeValue" class="w-8 text-right font-semibold text-xs ml-2">100%</span>
                </div>

                <!-- Velocidad (Rate) -->
                <div class="control-group">
                    <label for="rateSlider" class="text-sm mr-2 whitespace-nowrap" data-i18n="labelRate">Velocidad:</label>
                    <input type="range" id="rateSlider" min="0.5" max="2" step="0.1" value="1.0" class="w-20 h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                    <span id="rateValue" class="w-8 text-right font-semibold text-xs ml-2">1.0x</span>
                </div>
            </div>

            <!-- Botones de Control y Navegaci√≥n (Estilo Moderno) -->
            <div class="flex flex-wrap justify-center gap-3 sm:gap-4 pt-4">
                
                <!-- Bot√≥n Anterior -->
                <button id="prevParagraphButton" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-5 rounded-full flex items-center space-x-2 text-md shadow-md">
                    <span>‚è™</span>
                    <span data-i18n="buttonPrev" class="hidden sm:inline">P√°rrafo Anterior</span>
                </button>

                <!-- Bot√≥n Principal: Play/Pause/Resume -->
                <button id="playStopButton" class="bg-gray-700 hover:bg-gray-800 text-white font-extrabold py-3 px-8 rounded-full flex items-center space-x-3 text-lg shadow-xl ring-4 ring-gray-300">
                    <span id="playStopIcon">‚ñ∂Ô∏è</span>
                    <span id="playStopText" data-i18n="buttonPlay">Reproducir</span>
                </button>
                
                <!-- Bot√≥n Siguiente -->
                <button id="nextParagraphButton" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-5 rounded-full flex items-center space-x-2 text-md shadow-md">
                    <span data-i18n="buttonNext" class="hidden sm:inline">P√°rrafo Siguiente</span>
                    <span>‚è©</span>
                </button>
                
                <!-- Bot√≥n de Borrar -->
                <button id="clearButton" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-5 rounded-full flex items-center space-x-2 shadow-md">
                    <span>üóëÔ∏è</span>
                    <span data-i18n="buttonClear" class="hidden sm:inline">Borrar Texto</span>
                </button>
            </div>
        </div>

        <!-- Secci√≥n de Carga de PDF -->
        <div class="space-y-3 p-4 bg-blue-50 rounded-xl border border-blue-200">
            <label for="pdfFileInput" class="block text-lg font-bold text-blue-800" data-i18n="labelPdf">1. Cargar PDF para extracci√≥n de texto:</label>
            <input type="file" id="pdfFileInput" accept=".pdf" class="w-full text-sm text-blue-700 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-200 file:text-blue-800 hover:file:bg-blue-300 cursor-pointer"/>
        </div>

        <!-- Cuadro de Texto -->
        <div class="relative">
             <label for="textToRead" class="block text-lg font-bold text-gray-700 mb-2" data-i18n="labelTextarea">2. Texto a Leer (haz clic o selecciona texto):</label>
            <textarea id="textToRead" 
                      data-i18n-placeholder="placeholderTextarea"
                      placeholder="Escribe o pega el texto aqu√≠. El texto extra√≠do del PDF aparecer√° aqu√≠." 
                      rows="10"
                      class="w-full p-4 border-2 border-gray-300 rounded-xl focus:ring-blue-500 focus:border-blue-500 transition duration-150 ease-in-out resize-none text-base cursor-text font-serif">
            </textarea>
        </div>

        <!-- √Årea de Mensajes de Estado (para mostrar errores o feedback) -->
        <div id="messageArea" class="mt-4 p-3 bg-yellow-100 border border-yellow-300 text-yellow-800 rounded-lg hidden text-center font-medium">
            <!-- Los mensajes se insertan aqu√≠ din√°micamente -->
        </div>
        
        <!-- Autor√≠a y Anuncios (√Årea Reservada) -->
        <div class="mt-10 pt-4 border-t border-gray-300 text-center space-y-4">
            <p class="text-sm text-gray-600 font-medium">
                Autor: Emanuel Mandarini Falero
            </p>
            
            <!-- √Årea Reservada para Anuncios -->
            <div id="ad-space" class="bg-gray-200 p-4 rounded-lg border-2 border-dashed border-gray-400 text-gray-600 text-sm italic h-24 flex items-center justify-center">
                [Espacio Reservado para Anuncios]
                <br class="hidden sm:block">
                (Aqu√≠ se insertar√° el c√≥digo de Google AdSense o similar)
            </div>
        </div>
        
    </div>
    
    <!-- PDF.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
        // CR√çTICO: Configuraci√≥n de PDF.js Worker
        if (window.pdfjsLib) {
            window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
        }

        // --- Traducciones (i18n) ---
        const translations = {
            es: {
                // T√≠tulos actualizados
                pageTitle: 'Lector TTS Web',
                mainTitle: 'üéôÔ∏è Lector de Texto a Voz (TTS) Web',
                subTitle: 'Carga un PDF, pega texto, ajusta el volumen y navega. Haz clic o selecciona texto para empezar a leer.',
                labelPdf: '1. Cargar PDF para extracci√≥n de texto:',
                labelLanguage: 'Idioma:',
                labelVolume: 'Volumen:',
                labelRate: 'Velocidad:',
                labelParagraphCurrent: 'P√°rrafo Actual:',
                labelTextarea: '2. Texto a Leer (haz clic o selecciona texto):',
                placeholderTextarea: 'Escribe o pega el texto aqu√≠. El texto extra√≠do del PDF aparecer√° aqu√≠.',
                buttonPlay: 'Reproducir',
                buttonPause: 'Pausa',
                buttonResume: 'Reanudar',
                buttonPrev: 'P√°rrafo Anterior',
                buttonNext: 'P√°rrafo Siguiente',
                buttonClear: 'Borrar Texto',

                // Mensajes de alerta
                alertErrorNotSupported: 'ERROR: La API de Texto a Voz no est√° soportada por este navegador.',
                alertVoiceWarning: 'ADVERTENCIA: No se encontr√≥ una voz para este idioma. Usando la voz predeterminada del sistema.',
                alertVoiceError: (error) => `ERROR en la voz: ${error}. Intente otra velocidad o idioma.`,
                alertEnd: 'Fin de la lectura. Vuelve a Reproducir para empezar desde el inicio.',
                alertStart: 'Has llegado al inicio del texto.',
                alertPdfLoading: 'Extrayendo texto del PDF... Por favor, espere.',
                alertPdfError: (error) => `Error al cargar el PDF: ${error}. ¬øEs un archivo PDF v√°lido?`,
                alertPdfSuccess: '¬°Texto del PDF cargado exitosamente! Listo para leer.',
                alertPdfNotReady: 'El cargador de PDF no est√° listo. Intente de nuevo en un momento.',
            },
            en: {
                // T√≠tulos actualizados
                pageTitle: 'Web Text-to-Speech (TTS) Reader',
                mainTitle: 'üéôÔ∏è Web Text-to-Speech (TTS) Reader',
                subTitle: 'Upload a PDF, paste text, adjust volume, and navigate. Click or select text to start reading.',
                labelPdf: '1. Upload PDF for text extraction:',
                labelLanguage: 'Language:',
                labelVolume: 'Volume:',
                labelRate: 'Rate:',
                labelParagraphCurrent: 'Current Paragraph:',
                labelTextarea: '2. Text to Read (click or select text):',
                placeholderTextarea: 'Type or paste text here. Extracted PDF text will appear here.',
                buttonPlay: 'Play',
                buttonPause: 'Pause',
                buttonResume: 'Resume',
                buttonPrev: 'Previous Paragraph',
                extraTitle: '(Stabilized)',
                buttonNext: 'Next Paragraph',
                buttonClear: 'Clear Text',

                // Alert Messages
                alertErrorNotSupported: 'ERROR: Text-to-Speech API is not supported by this browser.',
                alertVoiceWarning: 'WARNING: No voice found for this language. Using the system default voice.',
                alertVoiceError: (error) => `Voice ERROR: ${error}. Try another rate or language.`,
                alertEnd: 'End of reading. Press Play again to start from the beginning.',
                alertStart: 'You have reached the start of the text.',
                alertPdfLoading: 'Extracting text from PDF... Please wait.',
                alertPdfError: (error) => `Error loading PDF: ${error}. Is it a valid PDF file?`,
                alertPdfSuccess: 'PDF text successfully loaded! Ready to read.',
                alertPdfNotReady: 'PDF loader is not ready. Please try again in a moment.',
            }
        };

        // --- Variables de Estado Global ---
        const synth = window.speechSynthesis;
        let utterance = null;
        let paragraphs = [];
        let currentParagraphIndex = -1;
        
        let currentLanguage = 'es'; 
        let esVoice = null; 
        let enVoice = null; 
        
        // CR√çTICO para la estabilidad: Este array es la SOLUCI√ìN al bug del corte de voz.
        let activeUtterances = []; 
        
        // Bandera: Indica si la reproducci√≥n fue detenida manualmente (navegaci√≥n o stop).
        let isManualStop = false; 
        
        // --- Referencias DOM ---
        const textToReadEl = document.getElementById('textToRead');
        const playStopButton = document.getElementById('playStopButton');
        const playStopIcon = document.getElementById('playStopIcon');
        const playStopText = document.getElementById('playStopText');
        const nextParagraphButton = document.getElementById('nextParagraphButton');
        const prevParagraphButton = document.getElementById('prevParagraphButton');
        const clearButton = document.getElementById('clearButton');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeValueEl = document.getElementById('volumeValue');
        const rateSlider = document.getElementById('rateSlider');
        const rateValueEl = document.getElementById('rateValue');
        const messageArea = document.getElementById('messageArea');
        const pdfFileInput = document.getElementById('pdfFileInput');
        const paragraphIndexDisplay = document.getElementById('paragraphIndexDisplay');
        const languageSelect = document.getElementById('languageSelect');

        // -------------------------------------------------------------------
        // 1. Funciones de Localizaci√≥n (i18n)
        // -------------------------------------------------------------------

        /** Actualiza todo el texto de la interfaz al idioma seleccionado. */
        function updateUIText() {
            const lang = currentLanguage;
            const t = translations[lang];

            document.title = t.pageTitle;
            document.documentElement.lang = lang; 

            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (t[key]) {
                    el.textContent = t[key];
                }
            });

            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.getAttribute('data-i18n-placeholder');
                if (t[key]) {
                    el.placeholder = t[key];
                }
            });

            // Forzar actualizaci√≥n de estado de bot√≥n
            updateButtonState();
        }

        /** Carga el texto de ejemplo en el textarea seg√∫n el idioma. */
        function updateTextByLanguage(lang) {
            if (lang === 'es') {
                textToReadEl.value = `¬°Bienvenido a tu Lector TTS Web!

La tecnolog√≠a Text-to-Speech (TTS) convierte texto digital en voz sintetizada. Esta funci√≥n es crucial para la accesibilidad.

Instrucciones:
1. Pega aqu√≠ el texto que quieras leer (o carga un PDF).
2. Haz clic en un p√°rrafo para empezar a leer desde all√≠, o selecciona una porci√≥n de texto.
3. Usa los botones 'Anterior' y 'Siguiente' para navegar por p√°rrafos, incluso mientras est√°s en pausa.`;
            } else {
                textToReadEl.value = `Welcome to your Web TTS Reader!

Text-to-Speech (TTS) technology converts digital text into synthesized speech. This function is crucial for accessibility.

Instructions:
1. Paste the text you want to read here (or upload a PDF).
2. Click on a paragraph to start reading from there, or select a portion of text.
3. Use the 'Previous' and 'Next' buttons to navigate paragraphs, even while paused.`;
            }
            // Forzar el redimensionamiento y el re-parseo de p√°rrafos
            textToReadEl.dispatchEvent(new Event('input')); 
            currentParagraphIndex = -1;
            updateParagraphDisplay();
        }

        // -------------------------------------------------------------------
        // 2. Funciones de Control TTS y Navegaci√≥n
        // -------------------------------------------------------------------

        /** Divide el texto del textarea en un array de p√°rrafos. */
        function parseParagraphs() {
            const rawText = textToReadEl.value;
            // Divide el texto por dos o m√°s saltos de l√≠nea consecutivos
            paragraphs = rawText.split(/\r?\n\s*\r?\n/).filter(p => p.trim() !== '');
            updateParagraphDisplay();
        }

        /** Actualiza el indicador de p√°rrafo actual (e.g., "1 de 5"). */
        function updateParagraphDisplay() {
            const total = paragraphs.length;
            // Muestra 0 si no hay lectura, si no, el √≠ndice + 1
            const current = currentParagraphIndex >= 0 && currentParagraphIndex < total ? currentParagraphIndex + 1 : 0;
            paragraphIndexDisplay.textContent = `${current} de ${total}`;
        }
        
        /** Resalta el p√°rrafo actual en el textarea. */
        function scrollToCurrentParagraph(startChar = null, endChar = null) {
            if (currentParagraphIndex < 0 || currentParagraphIndex >= paragraphs.length) return;
            
            const text = textToReadEl.value;
            let charIndex = 0;
            const newlineRegex = /\r?\n\s*\r?\n/; 

            const rawParagraphs = text.split(newlineRegex);
            let pStart = 0;
            
            // Busca la posici√≥n de inicio del p√°rrafo actual
            for (let i = 0; i < currentParagraphIndex && i < rawParagraphs.length; i++) {
                pStart += rawParagraphs[i].length + (text.substring(pStart + rawParagraphs[i].length).match(newlineRegex)?.[0]?.length || 2);
            }
            
            const start = pStart + (startChar || 0);
            const end = pStart + (endChar !== null ? endChar : paragraphs[currentParagraphIndex].length);

            textToReadEl.focus();
            textToReadEl.setSelectionRange(start, end); // Seleccionar el texto para resaltarlo
            
            // Opcional: Desplazar el scroll al p√°rrafo seleccionado
            // Esto es una aproximaci√≥n, puede no ser perfecto en todos los navegadores.
            const lineHeight = parseInt(getComputedStyle(textToReadEl).lineHeight);
            const lines = text.substring(0, start).split('\n').length;
            textToReadEl.scrollTop = (lines * lineHeight) - textToReadEl.clientHeight / 2;
        }

        /** * L√≥gica principal de reproducci√≥n de TTS. 
         * @param {string} text - El texto a leer.
         * @param {number} startCharIndex - √çndice de car√°cter dentro del texto del p√°rrafo donde iniciar (para selecci√≥n).
         */
        function speak(text, startCharIndex = 0) {
            if (!synth) {
                alertMessage(translations[currentLanguage].alertErrorNotSupported, 'bg-red-100 border-red-300 text-red-800');
                return;
            }
            
            const cleanedText = text ? text.trim() : '';

            // 1. Manejo de Reanudaci√≥n
            if (synth.paused) {
                synth.resume();
                updateButtonState();
                return;
            }
            
            // 2. Cancelar lectura anterior si est√° en curso (y no es pausa/resume)
            if (synth.speaking || synth.paused) {
                synth.cancel(); 
            }

            if (!cleanedText) {
                console.warn("Texto vac√≠o, no se puede reproducir.");
                return;
            }
            
            // 3. Preparaci√≥n de la voz (nueva utterance)
            utterance = new SpeechSynthesisUtterance(cleanedText);
            
            // Configurar Par√°metros
            utterance.volume = parseFloat(volumeSlider.value);
            utterance.rate = parseFloat(rateSlider.value);
            utterance.lang = currentLanguage === 'es' ? 'es-ES' : 'en-US'; 
            
            let selectedVoice = currentLanguage === 'es' ? esVoice : enVoice;
            
            if (selectedVoice) {
                utterance.voice = selectedVoice;
            } else {
                alertMessage(translations[currentLanguage].alertVoiceWarning, 'bg-yellow-100 border-yellow-300 text-yellow-800');
            }
            
            // CR√çTICO: A√±adir la referencia. 
            activeUtterances.push(utterance);

            // 4. Handlers de Eventos
            utterance.onstart = () => {
                updateButtonState(); // Cambiar a Pausa
                // Si la selecci√≥n es parcial, resaltar solo desde el inicio de la selecci√≥n hasta el final del p√°rrafo.
                scrollToCurrentParagraph(startCharIndex); 
            };
            
            utterance.onpause = () => {
                updateButtonState(); // Cambiar a Reanudar
            };

            // Implementaci√≥n de resaltado de palabra si el navegador lo soporta
            utterance.onboundary = (event) => {
                if (event.name === 'word') {
                    // event.charIndex es la posici√≥n de inicio de la palabra DENTRO de la utterance (el p√°rrafo)
                    const start = event.charIndex;
                    const length = event.charLength;
                    // Se usa startCharIndex para compensar el offset si la lectura NO empez√≥ al inicio del p√°rrafo.
                    scrollToCurrentParagraph(startCharIndex + start, startCharIndex + start + length);
                }
            };

            utterance.onend = () => {
                // Limpieza normal al finalizar
                
                const index = activeUtterances.indexOf(utterance);
                if (index > -1) {
                    activeUtterances.splice(index, 1);
                }
                utterance = null;
                
                // Si fue una cancelaci√≥n manual (navegaci√≥n o stop), ignoramos el avance autom√°tico.
                if (isManualStop) {
                    isManualStop = false; // Resetear la bandera
                    updateButtonState();
                    return;
                }

                // Auto-avanzar al siguiente p√°rrafo con un peque√±o retardo de seguridad
                setTimeout(() => {
                    goToNextParagraph(true); 
                }, 100); 
            };

            utterance.onerror = (event) => {
                console.error('TTS ERROR:', event);
                alertMessage(translations[currentLanguage].alertVoiceError(event.error), 'bg-red-100 border-red-300 text-red-800');
                
                const index = activeUtterances.indexOf(utterance);
                if (index > -1) {
                    activeUtterances.splice(index, 1);
                }
                utterance = null;
                stop(); // Asegurar que se cancela todo
            };
            
            // 5. Iniciar la reproducci√≥n
            updateParagraphDisplay();

            // Si hay un √≠ndice de inicio (por selecci√≥n), usamos el m√©todo substring para leer el resto del p√°rrafo.
            const textToSpeak = cleanedText.substring(startCharIndex);
            
            // Crear una nueva utterance con el texto truncado para iniciar desde all√≠.
            const truncatedUtterance = new SpeechSynthesisUtterance(textToSpeak);
            truncatedUtterance.volume = utterance.volume;
            truncatedUtterance.rate = utterance.rate;
            truncatedUtterance.lang = utterance.lang;
            truncatedUtterance.voice = utterance.voice;

            // Re-asignar handlers al truncatedUtterance (IMPORTANTE para que onend siga funcionando)
            // Se debe mantener la referencia a startCharIndex original para el scroll/resaltado.
            truncatedUtterance.onstart = () => {
                updateButtonState();
                scrollToCurrentParagraph(startCharIndex); 
            };
            truncatedUtterance.onpause = utterance.onpause;
            truncatedUtterance.onend = utterance.onend;
            truncatedUtterance.onerror = utterance.onerror;
            
            // El onboundary debe usar el startCharIndex para la posici√≥n global
            truncatedUtterance.onboundary = (event) => {
                if (event.name === 'word') {
                    const start = event.charIndex;
                    const length = event.charLength;
                    scrollToCurrentParagraph(startCharIndex + start, startCharIndex + start + length);
                }
            };


            // Reemplazar la referencia global (para onend)
            utterance = truncatedUtterance; 
            activeUtterances[activeUtterances.length - 1] = utterance;

            synth.speak(utterance);
        }

        /** Detiene toda la reproducci√≥n y borra el estado de la voz. */
        function stop() {
            if (synth.speaking || synth.paused) {
                isManualStop = true; // CR√çTICO: Marcamos que la detenci√≥n es manual
                synth.cancel();
            }
            // Borra la selecci√≥n de texto
            textToReadEl.setSelectionRange(0, 0); 
            updateButtonState();
        }
        
        /** Actualiza el texto y el √≠cono del bot√≥n principal (Play/Pause/Resume). */
        function updateButtonState() {
            const t = translations[currentLanguage];
            const isSpeaking = synth.speaking;
            const isPaused = synth.paused;
            
            // Resetear clases de color
            playStopButton.classList.remove('bg-gray-700', 'hover:bg-gray-800', 'bg-blue-500', 'hover:bg-blue-600', 'bg-red-500', 'hover:bg-red-600');

            if (isSpeaking && !isPaused) {
                playStopIcon.textContent = '‚è∏Ô∏è';
                playStopText.textContent = t.buttonPause;
                // Gris Oscuro para PAUSA
                playStopButton.classList.add('bg-gray-700', 'hover:bg-gray-800');
            } else if (isPaused) {
                playStopIcon.textContent = '‚ñ∂Ô∏è';
                playStopText.textContent = t.buttonResume;
                // Azul para REANUDAR
                playStopButton.classList.add('bg-blue-500', 'hover:bg-blue-600');
            } else {
                // 'stopped'
                playStopIcon.textContent = '‚ñ∂Ô∏è';
                playStopText.textContent = t.buttonPlay;
                // Gris Oscuro para REPRODUCIR (inicio)
                playStopButton.classList.add('bg-gray-700', 'hover:bg-gray-800');
            }
        }

        /** Navega y reproduce el siguiente p√°rrafo. */
        function goToNextParagraph(autoAdvance = false) {
            parseParagraphs();
            
            stop(); 

            if (paragraphs.length === 0) return;

            // Determinar el nuevo √≠ndice
            if (currentParagraphIndex === -1 && !autoAdvance) {
                currentParagraphIndex = 0;
            } else {
                currentParagraphIndex++;
            }
            
            if (currentParagraphIndex >= paragraphs.length) {
                // Fin del texto
                currentParagraphIndex = -1; 
                alertMessage(translations[currentLanguage].alertEnd, 'bg-green-100 border-green-300 text-green-800');
                updateParagraphDisplay();
                return;
            }

            // Despu√©s de asegurar el √≠ndice, reproducir desde el inicio del p√°rrafo
            speak(paragraphs[currentParagraphIndex], 0); 
        }

        /** Navega y reproduce el p√°rrafo anterior. */
        function goToPreviousParagraph() {
            parseParagraphs();
            
            stop(); 

            if (paragraphs.length === 0) return;

            if (currentParagraphIndex <= 0 || currentParagraphIndex >= paragraphs.length) {
                // Si no hay √≠ndice v√°lido, empieza al inicio
                currentParagraphIndex = 0;
            } else {
                currentParagraphIndex--;
            }

            if (currentParagraphIndex < 0) {
                currentParagraphIndex = 0;
                alertMessage(translations[currentLanguage].alertStart, 'bg-yellow-100 border-yellow-300 text-yellow-800');
                return; 
            }

            // Despu√©s de asegurar el √≠ndice, reproducir desde el inicio del p√°rrafo
            speak(paragraphs[currentParagraphIndex], 0);
        }
        
        /** Maneja el clic o la selecci√≥n en el textarea para iniciar la lectura. */
        function handleClickToRead(event) {
            parseParagraphs();

            if (paragraphs.length === 0) return;
            
            const startPosition = textToReadEl.selectionStart;
            const endPosition = textToReadEl.selectionEnd;

            // 1. Determinar la posici√≥n del clic/selecci√≥n dentro del texto total
            const clickPosition = (startPosition !== endPosition) ? startPosition : startPosition;

            let charCount = 0;
            const newlineRegex = /\r?\n\s*\r?\n/; 
            const rawText = textToReadEl.value;
            const rawParagraphs = rawText.split(newlineRegex);

            for (let i = 0; i < rawParagraphs.length; i++) {
                const paragraph = rawParagraphs[i];
                const cleanParagraph = paragraph.trim();

                // Calcular el inicio y fin del p√°rrafo RAW (incluyendo separadores)
                const pStart = charCount;
                const pEnd = charCount + paragraph.length;

                // 2. Comprobar si la posici√≥n de clic/selecci√≥n est√° dentro de este p√°rrafo RAW
                if (clickPosition >= pStart && clickPosition <= pEnd + 2) { 
                    
                    if (cleanParagraph.length > 0) {
                        
                        // Encontrar el √≠ndice del p√°rrafo limpio
                        const cleanIndex = paragraphs.findIndex(p => p === cleanParagraph);

                        if (cleanIndex !== -1) {
                            currentParagraphIndex = cleanIndex;
                            
                            // Calcular el √≠ndice de inicio DENTRO del P√ÅRRAFO CLEAN (offset)
                            let startCharIndexInParagraph;
                            
                            if (startPosition !== endPosition) {
                                // Es una selecci√≥n: Iniciar desde el inicio de la selecci√≥n
                                startCharIndexInParagraph = startPosition - pStart;
                            } else {
                                // Es un clic: Iniciar desde el inicio del p√°rrafo (0)
                                startCharIndexInParagraph = 0;
                            }
                            
                            // Asegurarse de que el √≠ndice no sea negativo y no exceda la longitud
                            startCharIndexInParagraph = Math.max(0, startCharIndexInParagraph);
                            startCharIndexInParagraph = Math.min(cleanParagraph.length, startCharIndexInParagraph);
                            
                            stop(); // Detener cualquier reproducci√≥n antes de iniciar la nueva
                            
                            speak(cleanParagraph, startCharIndexInParagraph);
                            return; 
                        }
                    }
                }
                
                // Avanza el contador de caracteres, incluyendo los separadores
                charCount += paragraph.length + (rawText.substring(charCount + paragraph.length).match(newlineRegex)?.[0]?.length || 2);
            }
        }

        /** Muestra un mensaje temporal en la UI. */
        function alertMessage(message, classes) {
            messageArea.textContent = message;
            messageArea.className = `mt-4 p-3 rounded-lg ${classes}`;
            messageArea.classList.remove('hidden');
            setTimeout(() => {
                messageArea.classList.add('hidden');
            }, 5000); // 5 segundos para que los mensajes sean visibles
        }

        // -------------------------------------------------------------------
        // 3. L√≥gica de Carga de PDF
        // -------------------------------------------------------------------

        /** Procesa un archivo PDF cargado por el usuario. */
        async function handlePdfUpload(event) {
            if (!window.pdfjsLib) {
                alertMessage(translations[currentLanguage].alertPdfNotReady, 'bg-red-100 border-red-300 text-red-800');
                return;
            }

            stop();
            textToReadEl.value = translations[currentLanguage].alertPdfLoading;
            alertMessage(translations[currentLanguage].alertPdfLoading, 'bg-gray-100 border-gray-300 text-gray-800');

            const file = event.target.files[0];
            if (!file) return;

            try {
                const fileReader = new FileReader();
                fileReader.onload = async function() {
                    const typedarray = new Uint8Array(this.result);
                    
                    // Cargar el documento PDF
                    const pdf = await pdfjsLib.getDocument({ data: typedarray }).promise;
                    let fullText = '';
                    
                    // Iterar por todas las p√°ginas
                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        const textContent = await page.getTextContent();
                        
                        // Unir el texto de la p√°gina y a√±adir un separador de p√°rrafo doble
                        fullText += textContent.items.map(item => item.str).join(' ') + '\n\n';
                    }
                    
                    textToReadEl.value = fullText.trim();
                    // Forzar actualizaci√≥n de UI y p√°rrafos
                    textToReadEl.dispatchEvent(new Event('input')); 
                    
                    currentParagraphIndex = -1;
                    updateParagraphDisplay();
                    
                    alertMessage(translations[currentLanguage].alertPdfSuccess, 'bg-green-100 border-green-300 text-green-800');
                    
                };
                fileReader.readAsArrayBuffer(file);
            } catch (error) {
                textToReadEl.value = '';
                console.error("Error al procesar el PDF:", error);
                alertMessage(translations[currentLanguage].alertPdfError(error.message), 'bg-red-100 border-red-300 text-red-800');
            }
            // Limpiar el input para permitir recargar el mismo archivo
            event.target.value = ''; 
        }
        
        // -------------------------------------------------------------------
        // 4. Event Listeners y Inicializaci√≥n
        // -------------------------------------------------------------------

        playStopButton.addEventListener('click', () => {
            parseParagraphs(); 
            
            if (synth.speaking && !synth.paused) {
                // Est√° reproduciendo -> Pausar
                synth.pause();
            } else if (synth.paused) {
                // Est√° pausado -> Reanudar
                // El resume interno de speak funciona, no necesita √≠ndice de inicio.
                speak(paragraphs[currentParagraphIndex]); 
            } else {
                // Detenido -> Reproducir
                if (currentParagraphIndex === -1 || currentParagraphIndex >= paragraphs.length) {
                    currentParagraphIndex = 0; // Empezar desde el inicio
                }
                if (paragraphs.length > 0) {
                    // Iniciar desde el comienzo del p√°rrafo 
                    speak(paragraphs[currentParagraphIndex], 0); 
                } else {
                    alertMessage("No hay texto para reproducir.", 'bg-red-100 border-red-300 text-red-800');
                }
            }
        });

        nextParagraphButton.addEventListener('click', () => {
            goToNextParagraph(false); 
        });
        
        prevParagraphButton.addEventListener('click', goToPreviousParagraph);

        clearButton.addEventListener('click', () => {
            textToReadEl.value = '';
            stop(); 
            currentParagraphIndex = -1; 
            parseParagraphs(); 
        });
        
        pdfFileInput.addEventListener('change', handlePdfUpload); 

        languageSelect.addEventListener('change', (e) => {
            currentLanguage = e.target.value;
            updateUIText(); 
            updateTextByLanguage(currentLanguage);
            stop(); 
        });

        volumeSlider.addEventListener('input', (e) => {
            const newVolume = parseFloat(e.target.value);
            volumeValueEl.textContent = `${Math.round(newVolume * 100)}%`;
            // Aplicar volumen a la utterance activa, si existe
            if (utterance) {
                utterance.volume = newVolume;
            }
        });
        
        rateSlider.addEventListener('input', (e) => {
            const newRate = parseFloat(e.target.value);
            rateValueEl.textContent = `${newRate.toFixed(1)}x`;
            
            // Si est√° leyendo o pausado, DEBEMOS CANCELAR Y REINICIAR con la nueva velocidad.
            if (synth.speaking || synth.paused) {
                
                // Determinar el punto de reinicio (donde se paus√≥/est√° leyendo)
                // Es complicado obtener el charIndex exacto al momento de la cancelaci√≥n.
                // Lo m√°s seguro es reiniciar el p√°rrafo actual.
                let startCharIndex = 0;
                
                stop();
                
                setTimeout(() => {
                    if (currentParagraphIndex !== -1 && paragraphs[currentParagraphIndex]) {
                         speak(paragraphs[currentParagraphIndex], startCharIndex);
                    }
                }, 150); 
            }
        });

        // NOTA: Usamos 'mouseup' en lugar de 'click' para detectar tanto clics simples como el final de una selecci√≥n.
        textToReadEl.addEventListener('mouseup', handleClickToRead);
        // Tambi√©n escuchamos 'keyup' para detectar selecciones hechas con teclado
        textToReadEl.addEventListener('keyup', (e) => {
            // Solo si se selecciona algo con las teclas y se suelta la tecla
            if (e.key.startsWith("Arrow") || e.key === "Shift") { 
                if (textToReadEl.selectionStart !== textToReadEl.selectionEnd) {
                    handleClickToRead();
                }
            }
        });

        // Auto-redimensionamiento y re-parseo de p√°rrafos al escribir
        textToReadEl.addEventListener('input', function () {
            // Ajuste de altura b√°sico
            this.style.height = 'auto';
            this.style.height = (this.scrollHeight) + 'px';
            parseParagraphs(); 
        });

        // Inicializaci√≥n de la aplicaci√≥n
        window.addEventListener('load', () => {
            if (!synth) {
                alertMessage(translations[currentLanguage].alertErrorNotSupported, 'bg-red-100 border-red-300 text-red-800');
                return;
            }
            
            // Funci√≥n para detectar voces cuando est√°n listas (puede ser as√≠ncrono)
            synth.onvoiceschanged = () => {
                const voices = synth.getVoices();
                
                // Buscar la primera voz en espa√±ol y la primera en ingl√©s
                esVoice = voices.find(voice => voice.lang.startsWith('es-')) || null;
                enVoice = voices.find(voice => voice.lang.startsWith('en-')) || null;

                if (!esVoice && !enVoice) {
                    alertMessage(translations[currentLanguage].alertVoiceWarning, 'bg-red-100 border-red-300 text-red-800');
                }
            };
            
            // Ejecutar si las voces ya est√°n cargadas
            if (synth.getVoices().length > 0) {
                synth.onvoiceschanged();
            }

            // Cargar UI y texto de ejemplo
            updateUIText(); 
            updateTextByLanguage(currentLanguage); 
            volumeValueEl.textContent = `${Math.round(parseFloat(volumeSlider.value) * 100)}%`;
            rateValueEl.textContent = `${parseFloat(rateSlider.value).toFixed(1)}x`;
        });
        
    </script>
</body>
</html>
